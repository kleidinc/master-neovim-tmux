# Why this book

<!-- > This book is an ongoing project. Every month I send out the <choose name> Update, -->
<!-- > with new plugins, updates, a curation of the best lectures on coding via email. -->
<!-- > Short, and to the point. [Sign-up here]() to stay up to date. -->

If you plan on becoming a master programmer, you will be programming for the majority of
your life. Even if you move up the career-ladder, you still will have to write code,
review code, refactor code and tinker. This will be something you will be doing daily.
And this is also how you will achieve and keep your mastery.

Your programming environment is as important as the languages you master, because you will
be using it daily for the rest of your life.

That's why mastering how to setup, configure, and program your programming environment is
as important as the code you will be writing.

The default config in this book is set up for Rust, markdown, lua you can easily extend it
to any programming language you want.

## Touch-typing on a split-keyboard

The mainstream keyboards are not optimized for programmers. That's why you will often see
proficient coders using mechanical keyboards, and more and more even split keyboards.

Your keyboard is your best friend. You will be using your keyboard through-out your whole
coding career. Touch typing is essential. Although you can start working with a mainstream
keyboard, I strongly suggest you get a mechanical split keyboard or at least a mechanical one.

The benefit of mechanical keys is that your fingers, and thus your brain, receives feedback.
That way you will learn to type faster easier.

And don't worry, if are not like me, who lives outside in the wilderness, you can choose
silent keys with a split keyboard:). I love nature, but that's for another time.

## Switch to TUI Neovim and Tmux

Although I have a love-hate relationship with open-source, it has given us amazing development
tools like neovim, tmux, lazygit and a never-ending influx of usefull plugins and a
thriving helpful community around it.

> The reason why I feel that open-source is broken, is that people, who provide truly useful
> code, are not adequately rewarded. I feel that the big tech monopolies
> abuse the open source community as modern day slaves. They use, abuse, learn from, and monetize,
> , open-source work for free. Even the current AI coding agents 'ab'use the open source code without
> remuneration.

I first switched from VSCode and Jetbrains to Neovim. Then I added tmux to the mix, and finally lazygit.
Now I can't even imagine going back to some 'commercial' product, that can't even come
close to my current workflow. It's not about the cost. They are just inferior to a well configured
personal programming environment.

I've become much faster. I can switch back, and forth between projects, in just a few
keystrokes, without leaving my work flow. I stay in the zone.

And trust me, once you start working with keys, instead of the mouse, you will train your mechanical
memory and after a few months, you won't even have to think about what keys are used for what commands.
Programming will become as natural as breathing.

This book will guide you through the process of installing, configuring and using your PPE, Personal
Programming Environment.

You will install, and configure your neovim, tmux, lazygit and learn about essential plugins.

## Read books, documentation and source-code of open-source projects

Our brains can process books quite good. Books are treasure-troves of information. I never thought I would
have to explain the benefits of a book, but here goes:

1. The information is structured, and you can easily find it.
2. You can read, re-read, ... and apply the steps.

The reason why I am writing this book, is because I haven't found a book covering how to configure your
Neovim, Tmux, and Lazygit terminal development environment. There are thousands of mixed-quality videos,
and so called-tutorials, but the absolute majority won't give you a complete setup.

Read the documentation.

Read the source-code of open source projects.

## Use AI wisely, or even better, don't use it.

First of all, AI is just machine learning from other people's code. So called AI can
not assertain the true quality of other people's code it is 'learning' from.

> Garbage in, garbage out.

Every
AI agent needs to learn from something. It needs data. Most of it, if not all, was
scraped (read stolen) from github, gitlab, and other repositories. If all the code used to train the AI
was perfect, then yes, over time we, the programmers, would become obsolete. But, guess what
, there is a reason why Windows, Linux, Android, Apple constantly push so-called security patches,
and updates. Even they write buggy code.

What do you think the quality of the majority of the code, used to train the AI agents, is?

## When to use AI

Only if you can't fix a problem yourself, try AI, and treat it as a stupid helper, a sort
of second opinion. Don't trust it 100%. Trust but verify, applies here. Try to understand why your
code didn't work. Your brain works best when it has to solve a problem.

Very important. Do not rely on AI to do the work for you. If AI can do it, you're not
even a programmer.

> If you are excited about AI, learn how to build AI models, and how to implement AI into your
> own products to improve them.

## Train your Programmer's Brain

Your brain is much more powerful than the strongest AI. When you write code yourself,
your brain works. When you are thinking about a coding problem, your brain works.
When you are refactoring code, your brain works.

Your brain will continuously practice and it will improve. Practice makes perfect.
And as you program more and more, and solve difficult problems, you will reach mastery.

You can only achieve mastery if you put in the work.

I will leave you with two thoughts.

> When you are copy-pasting code snippets from an AI agent, your brain becomes lazy, and
> you become stupid, and over time totally irrelevant and fired.

> You can't learn to play the piano, by watching someone else play the piano in a video. It's
> the same for coding. If you don't want to become irrelevant in 3 to 5 years, you need to code
> without AI. Then, and only then, will you reach a proficiency that will empower you to be
> part of the 1% of coders, who will still have a job.\_
